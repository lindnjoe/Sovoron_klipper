# Builds a grid of Z trigger points, taking the active bed mesh into consideration.
# The purpose is to find out if the bed mesh correctly compensates for bed uneveness.
#
# If the bed mesh is built using an eddy current sensor, and the probing is done by
# touching the nozzle to the bed, this can be used to verify the accuracy of the
# eddy current sensor.
#
# Usage: BED_MESH_OFFSETS_MEASURE GRID_MIN=30,30 GRID_MAX=270,255 PROBE_COUNT=5,5
#
# Parameters:
# - GRID_MIN:    the X and Y coordinates where to start probing (relative to the nozzle).
# - GRID_MAX:    the X and Y coordinates where to finish probing (relative to the nozzle).
# - PROBE_COUNT: the number of points to probe in X and Y direction
#
# NOTE: make sure that the coil stays over the bed with the given grid boundaries.
# The center of the coil should stay around 20 mm away from the borders of the bed.
# For example, if the probe has x=0 and y=22 offsets to the nozzle, GRID_MAX in Y direction
# should be `bed_max_y - 22 - 20`.
# Otherwise, the probe might not properly detect the bed during Contact probing.


# G28
# # Z_TILT_ADJUST or QUAD_GANTRY_LEVEL
# CARTOGRAPHER_TOUCH_HOME
# BED_MESH_OFFSETS_MEASURE GRID_MIN=16,45 GRID_MAX=330,285 PROBE_COUNT=5,5 # the mesh may be larger and more detailed than the mesh in the next line
# BED_MESH_OFFSETS_MEASURE GRID_MIN=16,45 GRID_MAX=330,285 PROBE_COUNT=5,5


[gcode_macro BED_MESH_OFFSETS_MEASURE]
variable_travel_speed: 150
variable_offsets: [] # used internally
variable_probe_command: "CARTOGRAPHER_TOUCH_PROBE"
variable_probe_read_result_command: "_BMO_CARTO_READ_PROBE_RESULT"
variable_probe_count_x: 0
variable_probe_count_y: 0
variable_probe_last_z_result: 0
variable_last_z_result: 0
gcode:
  SAVE_GCODE_STATE NAME=BED_MESH_OFFSETS_MEASURE

  SET_GCODE_VARIABLE MACRO=BED_MESH_OFFSETS_MEASURE VARIABLE=offsets VALUE="[]"

  {% if not 'xyz' in printer.toolhead.homed_axes %}
    {action_raise_error('Must home all axes first')}
  {% endif %}

  {% set grid_min = (params.GRID_MIN | default('') | string).split(',') %}
  {% set grid_max = (params.GRID_MAX | default('') | string).split(',') %}
  {% set probe_count = (params.PROBE_COUNT | default('3,3') | string).split(',') %}
  {% set format = params.FORMAT | default('table') | string %}

  {% if (grid_min | length) != 2 or (grid_max | length) != 2 %}
    {action_raise_error('Grid boundaries invalid')})}
  {% endif %}


  {% set x_min = grid_min[0] | int %}
  {% set y_min = grid_min[1] | int %}
  {% set x_max = grid_max[0] | int %}
  {% set y_max = grid_max[1] | int %}
  {% set probe_count_x = [probe_count[0] | int, 1] | max %}
  {% set probe_count_y = [probe_count[1] | int, 1] | max %}

  SET_GCODE_VARIABLE MACRO=BED_MESH_OFFSETS_MEASURE VARIABLE=probe_count_x VALUE={probe_count_x}
  SET_GCODE_VARIABLE MACRO=BED_MESH_OFFSETS_MEASURE VARIABLE=probe_count_y VALUE={probe_count_y}

  {% set x_coords = [] %}
  {% if probe_count_x == 1 %}
    {% set dummy = x_coords.append([0, (x_max + x_min) / 2]) %} # pick the center of the grid
  {% else %}
    {% for x_index in range(probe_count_x) %}
      {% set dummy = x_coords.append([x_index, x_min + x_index / (probe_count_x - 1) * (x_max - x_min)]) %}
    {% endfor %}
  {% endif %}

  {% set y_coords = [] %}
  {% if probe_count_y == 1 %}
    {% set dummy = y_coords.append([0, (y_max + y_min) / 2]) %} # pick the center of the grid
  {% else %}
    {% for y_index in range(probe_count_y) %}
      {% set dummy = y_coords.append([y_index, y_min + y_index / (probe_count_y - 1) * (y_max - y_min)]) %}
    {% endfor %}
  {% endif %}

  {% for y_index, y in y_coords %}
    {% for x_index, x in x_coords %}
      _BMO_PROBE_AT_POS X={x} X_IDX={x_index} Y={y} Y_IDX={y_index} F={travel_speed * 60}
    {% endfor %}
  {% endfor %}

  BMO_SHOW_RESULTS FORMAT='{format}'

  RESTORE_GCODE_STATE NAME=BED_MESH_OFFSETS_MEASURE


[gcode_macro _BMO_PROBE_AT_POS]
gcode:
  {% set x = params.X | default(0) | int %}
  {% set y = params.Y | default(0) | int %}
  {% set x_idx = params.X_IDX | default(0) | int %}
  {% set y_idx = params.Y_IDX | default(0) | int %}
  {% set vars = printer['gcode_macro BED_MESH_OFFSETS_MEASURE'] %}

  {% set speed = params.F | default(vars.travel_speed * 60) | int %}

  {action_respond_info("Probing point %d, %d (coords: %d, %d)" % (x_idx + 1, y_idx + 1, x, y))}

  G90
  G0 X{x} Y{y} F{speed}
  BMO_PROBE
  _BMO_ADD_OFFSET X={x} Y={y}


[gcode_macro BMO_PROBE]
gcode:
    {% set vars = printer['gcode_macro BED_MESH_OFFSETS_MEASURE'] %}
    
    SAVE_GCODE_STATE NAME=BMO_PROBE
    {vars.probe_command}
    {vars.probe_read_result_command}
    _BMO_PROBE_REPORT
    RESTORE_GCODE_STATE NAME=BMO_PROBE


[gcode_macro _BMO_PROBE_REPORT]
gcode:
    {% set vars = printer['gcode_macro BED_MESH_OFFSETS_MEASURE'] %}
    {% set mesh_offset = printer['gcode_move'].gcode_position[2] - printer['toolhead'].position[2] %}
    {% set offset = vars.probe_last_z_result + mesh_offset %}
    {action_respond_info('Z trigger point after mesh correction: {:.3f}'.format(offset))}
    SET_GCODE_VARIABLE MACRO=BED_MESH_OFFSETS_MEASURE VARIABLE=last_z_result VALUE="{offset}"       


[gcode_macro _BMO_ADD_OFFSET]
gcode:
    {% set x = params.X | int %}
    {% set y = params.Y | int %}
    {% set vars = printer['gcode_macro BED_MESH_OFFSETS_MEASURE'] %}
    {% set offsets = printer['gcode_macro BED_MESH_OFFSETS_MEASURE'].offsets %}
    {% set temp = offsets.append([x, y, vars.last_z_result]) %}
    SET_GCODE_VARIABLE MACRO=BED_MESH_OFFSETS_MEASURE VARIABLE=offsets VALUE="{offsets}"


[gcode_macro BMO_SHOW_RESULTS]
gcode:
    {% set vars = printer['gcode_macro BED_MESH_OFFSETS_MEASURE'] %}
    {% set probe_count_x = vars.probe_count_x %}
    {% set probe_count_y = vars.probe_count_y %}
    {% set format = params.FORMAT | default('table') | string %}
    {% set offsets = printer['gcode_macro BED_MESH_OFFSETS_MEASURE'].offsets %}

    {% if format == 'csv' %}
        # Comma separated (X, Y, offset)
        {% for y_index in range(probe_count_y) %}
            {% for x_index in range(probe_count_x) %}
                {% set x, y, offset = offsets[y_index * probe_count_x + x_index] %}
                {action_respond_info("%d,%d,%f" % (x, y, offset))}
            {% endfor %}
        {% endfor %}
    {% elif format == 'table' %}
        # Tabular output
  
        {% set vars = namespace(lines=[], header="") %}
        {% set colwidth = 8 %}

        # Header line
        {% set vars.header = '|{text:^{width}s}|'.format(text='Y \ X', width=colwidth) %}

        {% for x in offsets[0:probe_count_x] | map(attribute=0) | list %}
            {% set vars.header = vars.header + '{val:^{width}d}|'.format(val=x, width=colwidth) %}
        {% endfor %}
        {% set temp = vars.lines.append(vars.header) %}
  
        {% for y_index in range(probe_count_y - 1, -1, -1) %}
            {% set idx = y_index * probe_count_x %}
            {% set vars.line = '|{val:^{width}d}|'.format(val=offsets[idx][1], width=colwidth) %}
            {% for offset in offsets[idx:idx+probe_count_x] %}
                {% set vars.line = vars.line + "{val:{width}.3f}|".format(val=offset[2], width=colwidth) %}
            {% endfor %}
            {% set temp = vars.lines.append(vars.line) %}
        {% endfor %}
        {action_respond_info('Result:\n%s' % '\n'.join(vars.lines).replace(" ", "\u00A0"))} # replace space with non-breaking space as workaround for MainSail not displaying consecutive spaces properly
    {% endif %}


[gcode_macro _BMO_CARTO_READ_PROBE_RESULT]
gcode:
    {% set z_res = printer['cartographer'].touch.last_z_result %}
    SET_GCODE_VARIABLE MACRO=BED_MESH_OFFSETS_MEASURE VARIABLE=probe_last_z_result VALUE={z_res}