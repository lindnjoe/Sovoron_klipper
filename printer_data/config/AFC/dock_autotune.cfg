[gcode_macro TEST_ENDSTOP_REPEATABILITY]
variable_cache: {}
gcode:
    {% set axis    = params.get('AXIS','')|upper %}
    {% set cycles  = params.get('CYCLES', 10)|int %}
    {% set retract = params.get('RETRACT', 5)|float %}

    {% if axis not in ['X','Y','Z'] %}
        { action_respond_info("AXIS must be X, Y or Z") }
    {% elif cycles < 2 %}
        { action_respond_info("CYCLES must be ≥ 2") }
    {% else %}
        {% set step_name = 'stepper_' ~ axis|lower %}
        SET_GCODE_VARIABLE MACRO=TEST_ENDSTOP_REPEATABILITY VARIABLE=cache VALUE="{ { 'name': step_name, 'l': [] } }"
        {% set sign = '-' if printer.configfile.settings[step_name].get('homing_positive_dir', False) else '' %}
        { action_respond_info("Running test on %s-axis — %d cycles, retract %.2f mm" % (axis, cycles, retract)) }
        {% for i in range(cycles) %}
            G28 {axis}
            M400
            _TEST_ENDSTOP_REPEATABILITY RECORD={axis}
            G91
            G0 {axis}{sign}{retract}      ; relative retract
            G90
            M400
            G4 P100
        {% endfor %}
        _TEST_ENDSTOP_REPEATABILITY PROCESS={axis}
    {% endif %}

[gcode_macro _TEST_ENDSTOP_REPEATABILITY]
gcode:
    {% set cache = printer['gcode_macro TEST_ENDSTOP_REPEATABILITY'].cache %}
    {% if 'RECORD' in params %}
        {% set kin = printer.printer.lookup_object('toolhead').get_kinematics() %}
        {% set ns = namespace(stepper_obj=None) %}
        {% for s in kin.get_steppers() if s.get_name() == cache.name and not ns.stepper_obj %}
                {% set ns.stepper_obj = s %}
        {% endfor %}
        {% set _ = cache.l.append(ns.stepper_obj.get_mcu_position()) %}
        SET_GCODE_VARIABLE MACRO=TEST_ENDSTOP_REPEATABILITY VARIABLE=cache VALUE="{ cache }"
    {% elif 'PROCESS' in params %}
        {% set n = cache.l|length %}
        {% if n < 2 %}
            { action_respond_info("Not enough samples — got %d, need at least 2." % n) }
        {% else %}
            #---< steps/mm
            {% set cfg           = printer.configfile.settings[cache.name] %}
            {% set steps_per_rev = cfg.full_steps_per_rotation|float * cfg.microsteps|float %}
            {% set step_dist     = cfg.rotation_distance|float / steps_per_rev %}
            #---< min|max range
            {% set range_s  = cache.l|max - cache.l|min %}
            {% set range_mm = range_s * step_dist %}
            #---< std dev
            {% set ns       = namespace(ssd=0.0) %}
            {% set avg_s    = (cache.l|sum) / n %}
            {% for v in cache.l %}{% set ns.ssd = ns.ssd + (v - avg_s)**2 %}{% endfor %}
            {% set std_s    = (ns.ssd / n)**0.5 %}
            {% set std_mm   = std_s  * step_dist %}
            #---< report
            {% set _ = action_respond_info( [
                "="*40,
                "Endstop Repeatability Results — %s-axis" % cache.name|replace('stepper_', ''),
                "Cycles Run         : %d"      % n,
                "-"*20,
                "Range (Max-Min)    : %.6f mm  (%d steps)" % (range_mm, range_s),
                "Standard Deviation : %.6f mm  (%.2f steps)" % (std_mm, std_s),
                "-"*20,
                "Raw MCU steps      : %s" % cache.l,
                "="*40 ]|join('\n') ) %}
        {% endif %}
    {% endif %}


[tool_drop_detection]
accelerometer: "adxl345 T0", "adxl345 T1", "adxl345 T2", "adxl345 T3", "adxl345 T4", "adxl345 T5"
# polling_freq: 1
# polling_rate: 50

[gcode_macro TC_DOCK_AUTOTUNE]
description: "Autotune park_x / park_y for the *current* tool by minimising peak-g"
# ── SETTINGS ───────────────────────────────────────────────────────────
variable_range_mm:      0.5    # ± search window
variable_step_mm:       0.05    # mm increment
variable_pitch_tol:     45      # ° versus baseline
variable_roll_tol:      45
variable_threshold:     0.05   # 10 % peak increase considered "worse"
variable_changes_per:   6
variable_abort_on_g:    20
# --------------------------------------------
variable_debug:         False
variable_name:          'TC_DOCK_AUTOTUNE'
variable_storage:       {}
# ---------------------------------------------------------------------------
#  Entry
gcode:
  M400
  {% set P = printer %}
  {% set S = storage %}
  
  {% set state = S.get('state', 'idle') %}
  {% set actn = P.toolchanger.tool_number %} 
  {% if actn == -1 %}
    RESPOND TYPE=error MSG="No active tool equipped."
  {% elif state != 'idle' %}
    RESPOND MSG="Autotune already running (state={state})."
  {% elif P.toolhead.homed_axes != "xyz" %}
    RESPOND MSG="Please home first"
  {% else %}
    {% set storage = {} %}
    
    {% set tool_name = P.toolchanger.tool_names[actn] %}
    {% set tool_object      = P[tool_name] %}
    {% set x = tool_object.params_park_x|float %}
    {% set y = tool_object.params_park_y|float %}
    {% set z = tool_object.params_park_z|float %}

    {% set accelName = tool_object.get('params_accelerometer', tool_name|replace('tool ', ''))|replace('adxl345 ', '') %}

    SET_VELOCITY_LIMIT ACCEL={P.configfile.config.printer.max_accel|float // 5.0}
    G90
    STOP_TOOL_PROBE_CRASH_DETECTION

    {% set startingVars = [
        ('path_speed', tool_object.params_path_speed),
        ('tool',         actn),
        ('accelName',    accelName),
        ('orig_px',      x),
        ('orig_py',      y),
        ('state',        'start'),
    ] %}
    {% for k, v in startingVars %} {% set _ = storage.update({k: v}) %} {% endfor %}
    SET_GCODE_VARIABLE MACRO=TC_DOCK_AUTOTUNE VARIABLE=storage VALUE="{storage}"

    TDD_POLLING_STOP
    TDD_POLLING_START ACCEL={accelName} FREQ={20} RATE={1600}
    M400
    TDD_POLLING_RESET
    UPDATE_DELAYED_GCODE ID=_TCDOCK_LOOP DURATION=0
    UPDATE_DELAYED_GCODE ID=_TCDOCK_LOOP DURATION=3
    RESPOND MSG="Dock autotune started, range: ±{range_mm}mm and step: ±{step_mm}mm"
  {% endif %}
  # ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[delayed_gcode _TCDOCK_LOOP] # I LVOE STATE MACHINES I LOVE STATE MACHINES I LOVE STATE MACHINES
gcode:
    _TCDOCK_LOOP

[gcode_macro _TCDOCK_LOOP]
gcode:
    #========================================== VARIABLE INIT ==========================================
    {%- set debug = [] -%}
    {%- set P = printer -%}
    {%- set parent = P["gcode_macro TC_DOCK_AUTOTUNE"] -%}
    {%- set S = parent.storage -%}
    {%- set tool_object = P[P.toolchanger.tool_names[S.tool]] -%}
    {%- set tdd = P.tool_drop_detection.get(S.accelName) -%}
    {%- set pitch = tdd.current.rotation.pitch|float -%}
    {%- set roll = tdd.current.rotation.roll|float -%}
    {%- set peak = tdd.session.peak|float -%}
    {%- set sess_roll = tdd.session.rotation.roll|float -%}
    {%- set sess_pitch = tdd.session.rotation.pitch|float -%}
    {%- set state = S.get('state', 'idle') -%}
    {%- set max_accel = P.configfile.config.printer.max_accel|float -%}

    #========================================== MACROS ==========================================
    {%- macro loop(delay=0.25) -%}
        UPDATE_DELAYED_GCODE ID=_TCDOCK_LOOP DURATION=0
        UPDATE_DELAYED_GCODE ID=_TCDOCK_LOOP DURATION={delay}
    {%- endmacro -%}

    {%- macro store(k, v, mode="set") -%}
        {%- if mode == "add" -%}
        {%- if k not in S or S[k].__class__.__name__ != "list" -%}
            {%- set _ = S.update({k: []}) -%}
        {%- endif -%}
            {%- set _ = S[k].append(v) -%}
        {%- elif mode == "pop" -%}
            {%- set _ = S.pop(k, None) -%}
        {%- else -%}
            {%- set _ = S.update({k: v}) -%}
        {%- endif -%}
    {%- endmacro -%}

    {%- macro set_state(v) -%}{store("state", v)}{%- endmacro -%}
    # ───────────────────────────────────────────────────── 
    {%- macro guard_ok() -%}
        {%- set tilting   = (pitch|abs > parent.pitch_tol) or (roll|abs > parent.roll_tol) -%}
        {%- set high_g  = peak >= parent.abort_on_g|float -%}
        {%- set ok = False if high_g or tilting else True -%}
        {%- set _ = debug.append("guard_ok: " ~ ok|string) -%}
        {%- if not ok -%}
            {%- set _ = store("last_state", state) -%}
            {%- set _ = set_state("pause") -%}
        {%- endif -%}
        {- ok if ok else '' -}
    {%- endmacro -%}
    # ───────────────────────────────────────────────────── 
    {% macro run_test() %} # call to build up values, when done returns avreage and resets.
        {% set peaks = S.get('peaks') %}
        {% if peaks is none %} # first call, reset
            TDD_POLLING_RESET
            UNSELECT_TOOL
            SELECT_TOOL T={S.tool} RESTORE_AXIS=""
            {store('peaks', [])}
        {% elif peaks|length < parent.changes_per - 1 %} # record till full
            {store('peaks', peak, 'add')}
            TDD_POLLING_RESET
            UNSELECT_TOOL
            SELECT_TOOL T={S.tool} RESTORE_AXIS=""
        {% else %} # add last val and return avreage
            {% set avreage = ((S.peaks|sum + peak) / (S.peaks|length + 1))|round(5) %}
            {% set _ = debug.append("run_test avreage: " ~ avreage|string) %}
            {store('peaks', None, 'pop')}
            {store('peaks_avreage', avreage)}
        {% endif %}
        {% set _ = debug.append("run_test peaks: " ~ S.peaks|string) %}
        M400
        G4 P250
    {% endmacro %}
    #========================================== STATE MACHINE ==========================================
    {% if state == 'pause' %}
        {set_state("paused")}
        RESPOND TYPE=command MSG="action:prompt_begin Dock alignment issue"
        RESPOND TYPE=command MSG="action:prompt_text Pitch: {pitch|round(2)}°, Roll: {roll|round(2)}°"
        RESPOND TYPE=command MSG="action:prompt_text Peak: {peak|round(2)} g"
        RESPOND TYPE=command MSG="action:prompt_button Retry |UPDATE_DELAYED_GCODE ID=_TCDOCK_LOOP DURATION=0.1|warning"
        RESPOND TYPE=command MSG="action:prompt_show"
    {% endif %}

    {% if state == 'paused' %}
        {set_state(S.get('last_state', 'scan'))}
        TDD_POLLING_RESET
        {loop()}
    {% endif %}

    # ───────────────────────────────────────────────────── record shuttle rotation ─────────────────────
    {% if state == 'start' %}
        M400
        TDD_REFERENCE_SET ACCEL={S.accelName}
        {set_state('record_dock_baseline')}
        {loop()}
    {% endif %}
    # ───────────────────────────────────────────────────── record_dock_baseline ─────────────────────
    {% if state == 'record_dock_baseline' %}
        RESPOND MSG="Recording baseline, Unselecting"
        SET_VELOCITY_LIMIT ACCEL={max_accel // 10.0}
        SET_TOOL_PARAMETER T={S.tool} PARAMETER="params_path_speed" VALUE={S.path_speed|float // 5.0}
        UNSELECT_TOOL
        M400
        TDD_POLLING_RESET
        {set_state('record_rotation_baseline')}
        SET_TOOL_PARAMETER T={S.tool} PARAMETER="params_path_speed" VALUE={S.path_speed}
        SET_VELOCITY_LIMIT ACCEL={max_accel}
        {loop(delay=3)}
    {% endif %}
    # ───────────────────────────────────────────────────── record_rotation_baseline ─────────────────────
    {% if state == 'record_rotation_baseline' %}
        {store('dock_pitch', sess_pitch)}
        {store('dock_roll',  sess_roll)}
        TDD_POLLING_RESET
        SELECT_TOOL T={S.tool} RESTORE_AXIS=""
        {set_state('wait_user_accept_baseline')}
        M400
        {loop()}
    {% endif %}
    # ───────────────────────────────────────────────────── ask if okay ─────────────────────
    {% if state == 'wait_user_accept_baseline' %}
        RESPOND TYPE=command MSG="action:prompt_begin Dock alignment check"
        RESPOND TYPE=command MSG="action:prompt_text Current Tilt alignement:"
        RESPOND TYPE=command MSG="action:prompt_text f-b: {S.dock_pitch|round(3)}°"
        RESPOND TYPE=command MSG="action:prompt_text l-r: {S.dock_roll|round(3)}°"
        RESPOND TYPE=command MSG="action:prompt_button Record new |_TC_DOCK_AUTOTUNE_REDO_BASELINE_BUTTON|warning"
        RESPOND TYPE=command MSG="action:prompt_footer_button Continue |UPDATE_DELAYED_GCODE ID=_TCDOCK_LOOP DURATION=0.1|success"
        RESPOND TYPE=command MSG="action:prompt_show"
        {set_state('baseline')}
    {% endif %}
    # ───────────────────────────────────────────────────── baseline ─────────────────────
    {% if state == 'baseline' and guard_ok() %}
        RESPOND TYPE=command MSG="action:prompt_end"
        #SET_VELOCITY_LIMIT ACCEL={max_accel // 2.0}
        #SET_TOOL_PARAMETER T={S.tool} PARAMETER="params_path_speed" VALUE={S.path_speed|float // 2.0}
        {% set raw_peak = S.get('peaks_avreage') %}
        {% if raw_peak %}
            {store('peaks_avreage', None, 'pop')}  
            {% set base_peak = raw_peak|float %}
            {store('base_peak',  base_peak)}
            {store('best_peak',  base_peak)}
            RESPOND MSG="Baseline: {base_peak|round(3)}g,  dock_pitch: {S.dock_pitch|round(3)}°,  dock_roll: {S.dock_roll|round(3)}°"
            {set_state('scan')}
        {% else %}
            {run_test()}
        {% endif %}
        M400
        SET_VELOCITY_LIMIT ACCEL={max_accel}
        RESET_TOOL_PARAMETER T={S.tool} PARAMETER="params_path_speed"
        {loop(delay=1)}
    {% endif %}

    # ───────────────────────── scan initialisation ─────────────────────────
    {% if state == 'scan' %}
        {store('axis_list', ['x', 'y'])}                  # X first, then Y
        {store('dir_list',  [1, -1])}                     # + then –
        {store('axis_idx',   0)}
        {store('dir_idx',    0)}
        {store('cur_step',   0.0)}                        # signed offset in mm
        {store('best_x', tool_object.params_park_x|float)}
        {store('best_y', tool_object.params_park_y|float)}
        {store('param_set', False)}                       # flag: candidate already written?
        {set_state('scan_step')}
        {loop()}
    {% endif %}

        # ───────────────────────── single scan step ────────────────────────────
    {% if state == 'scan_step' and guard_ok() %}
        {% set axis     = S.axis_list[S.axis_idx] %}
        {% set dir_sign = S.dir_list[S.dir_idx] %}
        {% set step     = parent.step_mm|float * dir_sign %}
        {% set offset   = S.cur_step + step %}
        {% set max_off  = parent.range_mm|float %}

        # ── 1. overflow? advance direction / axis bookkeeping here ── #
        {% if offset|abs > max_off %}
            {% set new_dir = S.dir_idx + 1 %}
            {% if new_dir >= S.dir_list|length %}
                {store('dir_idx', 0)}
                {store('axis_idx', S.axis_idx + 1)}
            {% else %}
                {store('dir_idx', new_dir)}
            {% endif %}
            {store('cur_step', 0.0)}
            {store('param_set', False)}

            # done? — after an axis bump we may already be finished #
            {% if S.axis_idx >= S.axis_list|length %}
                {store('best_parking_pos_x', S.best_x)}
                {store('best_parking_pos_y', S.best_y)}
                {set_state('done')}
            {% endif %}
            {loop()}
        {% else %}
            # ── 2. write candidate co-ordinate once ── #
            {% if not S.param_set %}
            {% if axis == 'x' %}
                {% set cand_x = (S.best_x + offset)|round(3) %}
                {store('cand_x', cand_x)}                                           #  persist
                SET_TOOL_PARAMETER T={S.tool} PARAMETER=params_park_x VALUE={cand_x}
            {% else %}
                {% set cand_y = (S.best_y + offset)|round(3) %}
                {store('cand_y', cand_y)}                                           #  persist
                SET_TOOL_PARAMETER T={S.tool} PARAMETER=params_park_y VALUE={cand_y}
            {% endif %}
            {store('param_set', True)}
            M400
            {% endif %}

            # ── 3. collect / evaluate peak data ── #
            {% set raw_peak = S.pop('peaks_avreage', None) %}
            {% if raw_peak is none %}
                {run_test()}
                {loop()}
            {% else %}
                {store('peaks_avreage', None, 'pop')}             # keep storage clean
                {% set avg_peak = raw_peak|float %}
                {% set best     = S.best_peak|float %}
                {% set rel = ((avg_peak - best) / best) if best|float > 0 else (1.0 if avg_peak|float > 0 else 0.0) %}
                
                # strictly better by threshold
                {% if rel <= -parent.threshold|float %}
                    {store('best_peak', avg_peak)}
                    {% if axis == 'x' %}
                        {store('best_x', S.cand_x)}
                    {% else %}
                        {store('best_y', S.cand_y)}
                    {% endif %}
                     RESPOND MSG="Better -> axis={axis} offset={offset|round(3)} Δpeak={(avg_peak - best)|round(3)}g new={avg_peak|round(3)}g"
                    {store('cur_step', offset)}
                    {store('param_set', False)}

                # plateau: within tolerance; advance but do not update "best"
                {% elif rel > -parent.threshold|float and rel < parent.threshold|float %}
                    {store('cur_step', offset)}
                    {store('param_set', False)}
                    RESPOND MSG="Plateau -> axis={axis} offset={offset|round(3)} peak={avg_peak|round(3)}g best={best|round(3)}g"

                # worse by more than threshold -> revert and flip direction
                {% else %}
                    {% if axis == 'x' %}
                        RESPOND MSG="Found worse -> axis={axis} offset={offset|round(3)} peak={avg_peak|round(3)}g (resetting {S.cand_x} -> {S.best_x|round(3)})"
                        SET_TOOL_PARAMETER T={S.tool} PARAMETER=params_park_x VALUE={S.best_x|round(3)}
                    {% else %}
                        RESPOND MSG="Found worse -> axis={axis} offset={offset|round(3)} peak={avg_peak|round(3)}g (resetting {S.cand_y} -> {S.best_y|round(3)})"
                        SET_TOOL_PARAMETER T={S.tool} PARAMETER=params_park_y VALUE={S.best_y|round(3)}
                    {% endif %}
                    M400
                    {store('dir_idx',   S.dir_idx + 1)}
                    {store('cur_step',  0.0)}
                    {store('param_set', False)}
                {% endif %}

                # ── 4. advance axis / direction bookkeeping ── #
                {% if S.dir_idx >= S.dir_list|length %}
                    {store('dir_idx', 0)}
                    {store('axis_idx', S.axis_idx + 1)}
                    {store('cur_step', 0.0)}
                {% endif %}

                {% if S.axis_idx >= S.axis_list|length %}
                    {store('best_parking_pos_x', S.best_x)}
                    {store('best_parking_pos_y', S.best_y)}
                    {set_state('done')}
                {% endif %}
                {loop()}
            {% endif %}
        {% endif %}
    {% endif %}
    {% if state == 'done' %}
        TDD_POLLING_STOP
        SET_TOOL_PARAMETER T={S.tool} PARAMETER=params_park_x VALUE={S.best_parking_pos_x|round(3)}
        SET_TOOL_PARAMETER T={S.tool} PARAMETER=params_park_y VALUE={S.best_parking_pos_y|round(3)}
        {set_state('idle')}
        SET_VELOCITY_LIMIT ACCEL={P.configfile.config.printer.max_accel}
        RESPOND MSG="Done -> ΔX: {(S.best_parking_pos_x - S.orig_px)|round(3)}mm,  ΔY: {(S.best_parking_pos_y - S.orig_py)|round(3)}mm old peak: {S.base_peak|round(3)}g, new peak: {S.best_peak|round(3)}g"
        RESPOND MSG="params_park_x: {S.best_parking_pos_x|round(3)}"
        RESPOND MSG="params_park_y: {S.best_parking_pos_y|round(3)}"
    {% endif %}
    # always persist state
    SET_GCODE_VARIABLE MACRO=TC_DOCK_AUTOTUNE VARIABLE=storage VALUE="{S}"
    M400
    {% if debug != [] and parent.debug %} RESPOND MSG="{debug|join('<br>')|replace('/nl', '')}" {% endif %}
  

[gcode_macro _TC_DOCK_AUTOTUNE_REDO_BASELINE_BUTTON]
gcode:
  {% set storage = printer["gcode_macro TC_DOCK_AUTOTUNE"].storage %}
  {% set _ = storage.update({'state': 'record_dock_baseline'}) %}
  SET_GCODE_VARIABLE MACRO=TC_DOCK_AUTOTUNE VARIABLE=storage VALUE="{storage}"
  UPDATE_DELAYED_GCODE ID=_TCDOCK_LOOP DURATION=0.1